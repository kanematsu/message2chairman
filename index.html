<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>AR Messages</title>
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.3.2/aframe/build/aframe-ar.js"></script>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", sans-serif;
        background: #0b1220;
        color: #e2e8f0;
      }

      #hint {
        position: fixed;
        left: 50%;
        bottom: 20px;
        transform: translateX(-50%);
        padding: 10px 14px;
        background: rgba(11, 18, 32, 0.85);
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 10px;
        font-size: 14px;
        letter-spacing: 0.2px;
        backdrop-filter: blur(6px);
        z-index: 2;
        text-align: center;
      }
    </style>
  </head>
  <body>
    <div id="hint">マーカーを映しながらタップするとメッセージが切り替わります</div>

    <a-scene
      embedded
      vr-mode-ui="enabled: false"
      renderer="logarithmicDepthBuffer: true; antialias: true"
      arjs="sourceType: webcam; detectionMode: mono; debugUIEnabled: false;"
      device-orientation-permission-ui="enabled: false"
    >
      <a-assets>
        <canvas id="text-canvas" width="1024" height="512"></canvas>
      </a-assets>

      <a-marker id="marker" type="hiro" emitevents="true">
        <a-entity position="0 0.6 0">
          <a-plane
            id="message-plane"
            width="3.2"
            height="1.6"
            material="src: #text-canvas; side: double; transparent: true"
            position="0 0 0"
            rotation="-20 0 0"
          ></a-plane>
        </a-entity>
      </a-marker>

      <a-entity camera></a-entity>
    </a-scene>

    <script>
      (function () {
        const messages = [
          "NEOS Corp. ",
          "since 2000.03.31 - \n2025.11.30",
          "会長ご就任おめでとうございます。 社長としてお支えいただき、ありがとうございました。\ninage",
          "今後ともよろしくお願いいたします！\nkobayashi",
          "長い間お疲れさまでした。今後ともよろしくお願いいたします。\nowada",
          "社長勇退＆会長ご就任おめでとうございます。ご自愛のうえ、これからもお元気でお過ごしください。\nueki",
          "中途採用の面接でも、仕事・家庭で色々あって会話させてもらった時でも、",
          "立場が全然違うのにいつもフラットに話を聞いて頂けました。",
          "それが無ければ今日までやってこれていないと思います。これからも良い意味で、",
          "社員に近しい存在でいて頂けるとありがたいです！\ntakayama",
          "会長ご就任おめでとうございます。社長として日々支えていただき、",
          "本当にありがとうございました。今後ともよろしくお願いいたします。\nkanematsu",
          "Thank you, President.",
          "Hello, Chairman.",
        ];

        const scene = document.querySelector("a-scene");
        const plane = document.getElementById("message-plane");
        const canvas = document.getElementById("text-canvas");
        const ctx = canvas.getContext("2d");
        let index = 0;
        let animFrame = null;
        let lastTime = 0;
        let charIndex = 0;
        const charDelay = 45; // ms per character for a Famicom-like type effect

        const wrapText = (value, maxWidth) => {
          const lines = [];
          let line = "";
          for (const char of value) {
            if (char === "\n") {
              lines.push(line);
              line = "";
              continue;
            }
            const testLine = line + char;
            const width = ctx.measureText(testLine).width;
            if (width > maxWidth && line !== "") {
              lines.push(line);
              line = char;
            } else {
              line = testLine;
            }
          }
          lines.push(line);
          return lines;
        };

        const drawRoundedRect = (x, y, w, h, r) => {
          const radius = Math.min(r, w / 2, h / 2);
          ctx.beginPath();
          ctx.moveTo(x + radius, y);
          ctx.lineTo(x + w - radius, y);
          ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
          ctx.lineTo(x + w, y + h - radius);
          ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
          ctx.lineTo(x + radius, y + h);
          ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
          ctx.lineTo(x, y + radius);
          ctx.quadraticCurveTo(x, y, x + radius, y);
          ctx.closePath();
        };

        const drawCard = (textValue) => {
          const w = canvas.width;
          const h = canvas.height;
          ctx.clearRect(0, 0, w, h);

          const cardMargin = 36;
          const cardW = w - cardMargin * 2;
          const cardH = h - cardMargin * 2;

          ctx.save();
          ctx.shadowColor = "rgba(0, 0, 0, 0.35)";
          ctx.shadowBlur = 20;
          ctx.shadowOffsetY = 16;
          drawRoundedRect(cardMargin, cardMargin, cardW, cardH, 42);
          ctx.fillStyle = "#0a0a0a";
          ctx.fill();
          ctx.restore();

          drawRoundedRect(cardMargin, cardMargin, cardW, cardH, 42);
          ctx.strokeStyle = "#f6f7fb";
          ctx.lineWidth = 10;
          ctx.stroke();

          ctx.fillStyle = "#f7f7f7";
          ctx.textAlign = "left";
          ctx.textBaseline = "middle";
          ctx.font = "bold 64px 'Press Start 2P', 'M PLUS 1p', 'Noto Sans JP', 'Noto Sans CJK JP', 'Yu Gothic', 'Helvetica Neue', Arial, monospace";

          const textBoxW = cardW * 0.82;
          const textStartX = (w - textBoxW) / 2;
          const lines = wrapText(textValue, textBoxW);
          const lineHeight = 80;
          const startY = h / 2 - ((lines.length - 1) * lineHeight) / 2;
          lines.forEach((line, i) => {
            ctx.fillText(line, textStartX, startY + i * lineHeight);
          });

          const mesh = plane.getObject3D("mesh");
          if (mesh && mesh.material && mesh.material.map) {
            mesh.material.map.needsUpdate = true;
          }
        };

        const animateMessage = () => {
          if (animFrame) cancelAnimationFrame(animFrame);
          charIndex = 0;
          lastTime = 0;

          const step = (timestamp) => {
            if (!lastTime) lastTime = timestamp;
            const delta = timestamp - lastTime;
            if (delta >= charDelay && charIndex < messages[index].length) {
              charIndex += 1;
              lastTime = timestamp;
            }
            const partial = messages[index].slice(0, charIndex);
            drawCard(partial);
            if (charIndex < messages[index].length) {
              animFrame = requestAnimationFrame(step);
            }
          };

          animFrame = requestAnimationFrame(step);
        };

        const advanceMessage = () => {
          index = (index + 1) % messages.length;
          animateMessage();
        };

        const attachListeners = () => {
          const handler = () => advanceMessage();
          const touchHandler = (event) => {
            event.preventDefault();
            advanceMessage();
          };
          scene.addEventListener("click", handler);
          scene.addEventListener("touchstart", touchHandler, { passive: false });
        };

        if (scene.hasLoaded) {
          animateMessage();
          attachListeners();
        } else {
          scene.addEventListener("loaded", () => {
            animateMessage();
            attachListeners();
          });
        }
      })();
    </script>
  </body>
</html>
