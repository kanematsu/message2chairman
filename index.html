<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>AR Messages</title>
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.3.2/aframe/build/aframe-ar.js"></script>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", sans-serif;
        background: #0b1220;
        color: #e2e8f0;
      }

      #hint {
        position: fixed;
        left: 50%;
        bottom: 20px;
        transform: translateX(-50%);
        padding: 10px 14px;
        background: rgba(11, 18, 32, 0.85);
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 10px;
        font-size: 14px;
        letter-spacing: 0.2px;
        backdrop-filter: blur(6px);
        z-index: 2;
        text-align: center;
      }
    </style>
  </head>
  <body>
    <div id="hint">マーカーを映しながらタップするとメッセージが切り替わります</div>

    <a-scene
      embedded
      vr-mode-ui="enabled: false"
      renderer="logarithmicDepthBuffer: true; antialias: true"
      arjs="sourceType: webcam; detectionMode: mono; debugUIEnabled: false;"
      device-orientation-permission-ui="enabled: false"
    >
      <a-assets>
        <canvas id="text-canvas" width="1024" height="512"></canvas>
      </a-assets>

      <a-marker id="marker" type="hiro" emitevents="true">
        <a-entity position="0 0.6 0">
          <a-plane
            id="message-plane"
            width="3.2"
            height="1.6"
            material="src: #text-canvas; side: double; transparent: true"
            position="0 0 0"
            rotation="-20 0 0"
          ></a-plane>
        </a-entity>
      </a-marker>

      <a-entity camera></a-entity>
    </a-scene>

    <script>
      (function () {
        const messages = [
          "Thank you for 25 years",
          "会長ご就任おめでとうございます。 社長としてお支えいただき、ありがとうございました。",
          "今後ともよろしくお願いいたします！",
          "長い間お疲れさまでした。今後ともよろしくお願いいたします。",
          "社長勇退＆会長ご就任おめでとうございます。ご自愛のうえ、これからもお元気でお過ごしください。",
          "中途採用の面接でも、仕事・家庭で色々あって会話させてもらった時でも、立場が全然違うのにいつもフラットに話を聞いて頂けました。それが無ければ今日までやってこれていないと思います。これからも良い意味で、社員に近しい存在でいて頂けるとありがたいです！",
        ];

        const scene = document.querySelector("a-scene");
        const plane = document.getElementById("message-plane");
        const canvas = document.getElementById("text-canvas");
        const ctx = canvas.getContext("2d");
        let index = 0;

        const wrapText = (value, maxWidth) => {
          const lines = [];
          let line = "";
          for (const char of value) {
            const testLine = line + char;
            const width = ctx.measureText(testLine).width;
            if (width > maxWidth && line !== "") {
              lines.push(line);
              line = char;
            } else {
              line = testLine;
            }
          }
          if (line) lines.push(line);
          return lines;
        };

        const drawRoundedRect = (x, y, w, h, r) => {
          const radius = Math.min(r, w / 2, h / 2);
          ctx.beginPath();
          ctx.moveTo(x + radius, y);
          ctx.lineTo(x + w - radius, y);
          ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
          ctx.lineTo(x + w, y + h - radius);
          ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
          ctx.lineTo(x + radius, y + h);
          ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
          ctx.lineTo(x, y + radius);
          ctx.quadraticCurveTo(x, y, x + radius, y);
          ctx.closePath();
        };

        const updateMessage = () => {
          const w = canvas.width;
          const h = canvas.height;
          ctx.clearRect(0, 0, w, h);

          const cardMargin = 36;
          const cardW = w - cardMargin * 2;
          const cardH = h - cardMargin * 2;

          ctx.save();
          ctx.shadowColor = "rgba(0, 0, 0, 0.18)";
          ctx.shadowBlur = 24;
          ctx.shadowOffsetY = 16;
          drawRoundedRect(cardMargin, cardMargin, cardW, cardH, 42);
          const gradient = ctx.createLinearGradient(0, 0, w, h);
          gradient.addColorStop(0, "#fdfcf9");
          gradient.addColorStop(1, "#f4f0e7");
          ctx.fillStyle = gradient;
          ctx.fill();
          ctx.restore();

          drawRoundedRect(cardMargin, cardMargin, cardW, cardH, 42);
          ctx.strokeStyle = "#caa45a";
          ctx.lineWidth = 8;
          ctx.stroke();

          ctx.fillStyle = "#1a1a1a";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.font = "bold 72px 'Hiragino Sans', 'Noto Sans JP', 'Noto Sans CJK JP', 'Yu Gothic', 'Helvetica Neue', Arial, sans-serif";

          const lines = wrapText(messages[index], cardW * 0.82);
          const lineHeight = 88;
          const startY = h / 2 - ((lines.length - 1) * lineHeight) / 2;
          lines.forEach((line, i) => {
            ctx.fillText(line, w / 2, startY + i * lineHeight);
          });

          const mesh = plane.getObject3D("mesh");
          if (mesh && mesh.material && mesh.material.map) {
            mesh.material.map.needsUpdate = true;
          }
        };

        const advanceMessage = () => {
          index = (index + 1) % messages.length;
          updateMessage();
        };

        const attachListeners = () => {
          const handler = () => advanceMessage();
          const touchHandler = (event) => {
            event.preventDefault();
            advanceMessage();
          };
          scene.addEventListener("click", handler);
          scene.addEventListener("touchstart", touchHandler, { passive: false });
        };

        if (scene.hasLoaded) {
          updateMessage();
          attachListeners();
        } else {
          scene.addEventListener("loaded", () => {
            updateMessage();
            attachListeners();
          });
        }
      })();
    </script>
  </body>
</html>
